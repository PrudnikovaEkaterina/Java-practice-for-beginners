package day18;
//Вам необходимо создать двоичное дерево поиска, изображенное на картинке выше.
//Для этого создайте класс “Узел” (англ. Node), объекты которого будут содержать само значение узла
// и поля-ссылки на два других узла (левый и правый сын).
//Затем, создайте корневой (англ. root) узел (со значением 20).
//После этого, необходимо реализовать метод, который будет добавлять новые узлы в ваше дерево.
//Этот метод должен принимать в качестве аргументов добавляемое значение и ссылку на корень дерева.
// Проходясь по дереву, он должен вставлять новый узел в правильное место дерева.
//Когда двоичное дерево, изображенное выше, будет создано, необходимо используя рекурсию вывести в консоль
// все числа из этого двоичного дерева поиска в отсортированном виде. Ваше рекурсивное решение должно работать
// для любого корректного двоичного дерева поиска. Этот алгоритм называется “обход в глубину”
// (иногда называют “поиск в глубину”).
//Ваш рекурсивный метод (пусть он будет называться dfs) должен в качестве единственного аргумента принимать
// ссылку на корень дерева (root).
//
//Вызов: dfs(root);
//Вывод в консоль: 5 8 11 14 15 16 18 20 22 23 24 27 150

public class Task3 {
    public static void main(String[] args) {
        Node root =new Node(20);
        Node.buildTree(root, 14);
        Node.buildTree(root,23);
        Node.buildTree(root,11);
        Node.buildTree(root, 16);
        Node.buildTree(root, 22);
        Node.buildTree(root, 27);
        Node.buildTree(root, 5);
        Node.buildTree(root, 15);
        Node.buildTree(root, 18);
        Node.buildTree(root, 24);
        Node.buildTree(root, 150);
        Node.buildTree(root, 8);
    Node.print(root);




    }
}